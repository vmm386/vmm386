/* inslen.c -- Decode the length of an instruction.
   John Harper. */

#include <vmm/types.h>
#include <vmm/vm.h>

/* Bit definitions. */
#define OT_MOD_RM	0x01	/* Ins. has a mod r/m field. */
#define OT_WORD		0x02	/* 16/32 bit opcode. */
#define OT_EXT		0x04	/* Link into the other table. */
#define OT_PFX		0x08	/* Opcode is a prefix byte. */
#define OT_TAIL_BYTE	0x10	/* Opcode is followed by one byte. */
#define OT_TAIL_WIDTH	0x20	/* Opcode is followed by WIDTH bytes. */
#define OT_TAIL_PTR	0x80	/* 32 or 48 (depending on opsiz) pointer. */

const u_char opcode_table[256] =
{
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x00, 0x00,	/* 00 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x00, 0x04,	/* 08 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x00, 0x00,	/* 10 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x00, 0x00,	/* 18 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x08, 0x00,	/* 20 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x08, 0x00,	/* 28 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x08, 0x00,	/* 30 */
    0x01, 0x03, 0x01, 0x03, 0x10, 0x12, 0x08, 0x00,	/* 38 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 40 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 48 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 50 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 58 */
    0x00, 0x00, 0x01, 0x01, 0x08, 0x08, 0x08, 0x08,	/* 60 */
    0x10, 0x81, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00,	/* 68 */
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,	/* 70 */
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,	/* 78 */
    0x11, 0x23, 0x00, 0x13, 0x01, 0x03, 0x01, 0x03,	/* 80 */
    0x01, 0x03, 0x01, 0x03, 0x03, 0x01, 0x03, 0x03,	/* 88 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 90 */
    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 98 */
    0x10, 0x20, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00,	/* A0 */
    0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* A8 */
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,	/* B0 */
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	/* B8 */
    0x11, 0x13, 0x20, 0x00, 0x80, 0x80, 0x11, 0x23,	/* C0 */
    0x30, 0x00, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00,	/* C8 */
    0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,	/* D0 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* D8 */
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,	/* E0 */
    0x20, 0x20, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,	/* E8 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,	/* F0 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B,	/* F8 */
};

/* Note that MOVZX and MOVSZ aren't supported :-( */
const u_char opcode_ext_table[256] =
{
    0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00,	/* 00 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 08 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 10 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 18 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 20 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 28 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 30 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 38 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 40 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 48 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 50 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 58 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 60 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 68 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 70 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 78 */
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	/* 80 */
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,	/* 88 */
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,	/* 90 */
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,	/* 98 */
    0x00, 0x00, 0x00, 0x03, 0x13, 0x03, 0x00, 0x00,	/* A0 */
    0x00, 0x00, 0x00, 0x03, 0x13, 0x03, 0x00, 0x03,	/* A8 */
    0x00, 0x00, 0x81, 0x03, 0x81, 0x81, 0x00, 0x00,	/* B0 */
    0x00, 0x00, 0x13, 0x03, 0x03, 0x03, 0x00, 0x00,	/* B8 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* C0 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* C8 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* D0 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* D8 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* E0 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* E8 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* F0 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* F8 */
};

#define POP_BYTE (in_user ? get_user_byte(pc++) : *pc++)

/* Attempt to calculate the size of the instruction (in bytes) at address
   PC. If IN-USER is true PC is an address in the *user* segment of the
   current task. If IS-32BIT is true the instruction is 32-bit, else
   it's 16-bit. I don't guarantee the results of this function; it
   seems to work ok but who knows? Also MOVZX and MOVSZ definitely aren't
   supported (yet). */
size_t
get_inslen(u_char *pc, bool in_user, bool is_32bit)
{
    u_char *orig_pc = pc;
    u_char byte;
    bool addr_pfx = FALSE, op_pfx = FALSE;
    const u_char *this_opcode_table = opcode_table;

again:
    switch((byte = POP_BYTE))
    {
    case 0x80:
    case 0x2e:
    case 0x3e:
    case 0x26:
    case 0x64:
    case 0x65:
    case 0x36:
	goto again;
    case 0x67:
	addr_pfx = TRUE;
	goto again;
    case 0x66:
	op_pfx =TRUE;
	goto again;
    }

    byte = this_opcode_table[byte];

    if(byte & OT_EXT)
    {
	this_opcode_table = opcode_ext_table;
	goto again;
    }

    if(byte & OT_MOD_RM)
    {
	/* Skip mod r/m field. */
	u_char r_m = POP_BYTE;
	u_char mod = (r_m & 0xc0) >> 6;
	bool mode_32 = (byte & OT_WORD) && (is_32bit ^ addr_pfx);
	r_m &= 0x7;
	if(!mode_32)
	{
	    if(mod == 0)
	    {
		if(r_m == 6)
		    pc += 2;
	    }
	    else if(mod == 1)
		pc += 1;
	    else if(mod == 2)
		pc += 2;
	}
	else if(mod != 3)
	{
	    if(r_m == 4)
	    {
		/* Skip s-i-b byte */
		if(mod == 1)
		    pc += 1;
		else if(mod == 2)
		    pc += 4;
	    }
	    else if(mod == 0)
	    {
		if(r_m == 5)
		    pc += 4;
	    }
	    else if(mod == 1)
		pc += 1;
	    else if(mod == 2)
		pc += 4;
	}
    }

    if(byte & OT_TAIL_BYTE)
	pc++;
    if(byte & OT_TAIL_WIDTH)
	pc += op_pfx ? (is_32bit ? 2 : 4) : (is_32bit ? 4 : 2);
    if(byte & OT_TAIL_PTR)
	pc += op_pfx ? 6 : 4;

    return pc - orig_pc;
}
