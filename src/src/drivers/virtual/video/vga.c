/* vga.c -- VGA manipulation. Most of the techniques for this stuff
   come from Linux' VGAlib.
   John Harper. */

#include <vmm/types.h>
#include <vmm/video.h>
#include <vmm/vga.h>


/* VGA register sets for the various BIOS modes. */

/* BIOS mode 0x00 */
static const u_char mode0_regs[60] = {
  0x2D,0x27,0x28,0x90,0x2B,0xA0,0xBF,0x1F,0x00,0x4F,0x0D,0x0E,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x14,0x1F,0x96,0xB9,0xA3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,0x38,0x39,0x3A,0x3B,
  0x3C,0x3D,0x3E,0x3F,0x0C,0x00,0x0F,0x08,0x00,
  0x00,0x00,0x00,0x00,0x00,0x10,0x0E,0x00,0xFF,
  0x03,0x08,0x03,0x00,0x02,
  0x67
};
static const struct mode_info mode0_info = {
    40, 25, (char *)0xb8000, 2048, 8, TRUE, FALSE
};

/* BIOS mode 0x01 */
static const u_char mode1_regs[60] = {
  0x2D,0x27,0x28,0x90,0x2B,0xA0,0xBF,0x1F,0x00,0x4F,0x0D,0x0E,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x14,0x1F,0x96,0xB9,0xA3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,0x38,0x39,0x3A,0x3B,
  0x3C,0x3D,0x3E,0x3F,0x0C,0x00,0x0F,0x08,0x00,
  0x00,0x00,0x00,0x00,0x00,0x10,0x0E,0x00,0xFF,
  0x03,0x08,0x03,0x00,0x02,
  0x67
};
static const struct mode_info mode1_info = {
    40, 25, (char *)0xb8000, 2048, 8, TRUE, TRUE
};

/* BIOS mode 0x02 */
static const u_char mode2_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x55,0x81,0xBF,0x1F,0x00,0x4F,0x0D,0x0E,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x1F,0x96,0xB9,0xA3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,0x38,0x39,0x3A,0x3B,
  0x3C,0x3D,0x3E,0x3F,0x0C,0x00,0x0F,0x08,0x00,
  0x00,0x00,0x00,0x00,0x00,0x10,0x0E,0x00,0xFF,
  0x03,0x00,0x03,0x00,0x02,
  0x67
};
static const struct mode_info mode2_info = {
    80, 25, (char *)0xb8000, 2048, 4, TRUE, FALSE
};

/* BIOS mode 0x03 */
static const u_char mode3_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x55,0x81,0xBF,0x1F,0x00,0x4F,0x0D,0x0E,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x1F,0x96,0xB9,0xA3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,0x38,0x39,0x3A,0x3B,
  0x3C,0x3D,0x3E,0x3F,0x0C,0x00,0x0F,0x08,0x00,
  0x00,0x00,0x00,0x00,0x00,0x10,0x0E,0x00,0xFF,
  0x03,0x00,0x03,0x00,0x02,
  0x67
};
static const struct mode_info mode3_info = {
    80, 25, (char *)0xb8000, 4096, 4, TRUE, TRUE
};

/* BIOS mode 0x04 */
static const u_char mode4_regs[60] = {
  0x2D,0x27,0x28,0x90,0x2B,0x80,0xBF,0x1F,0x00,0xC1,0x00,0x00,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x14,0x00,0x96,0xB9,0xA2,
  0x00,0x13,0x15,0x17,0x02,0x04,0x06,0x07,0x10,0x11,0x12,0x13,
  0x14,0x15,0x16,0x17,0x01,0x00,0x03,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x30,0x0F,0x00,0xFF,
  0x03,0x09,0x03,0x00,0x02,
  0x63
};
static const struct mode_info mode4_info = {
    320, 200, (char *)0xb8000, 8192, 4, FALSE, TRUE
};

/* BIOS mode 0x05 */
static const u_char mode5_regs[60] = {
  0x2D,0x27,0x28,0x90,0x2B,0x80,0xBF,0x1F,0x00,0xC1,0x00,0x00,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x14,0x00,0x96,0xB9,0xA2,
  0x00,0x13,0x15,0x17,0x02,0x04,0x06,0x07,0x10,0x11,0x12,0x13,
  0x14,0x15,0x16,0x17,0x01,0x00,0x03,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x30,0x0F,0x00,0xFF,
  0x03,0x09,0x03,0x00,0x02,
  0x63
};
static const struct mode_info mode5_info = {
    320, 200, (char *)0xb8000, 8192, 4, FALSE, FALSE
};

/* BIOS mode 0x06 */
static const u_char mode6_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0xC1,0x00,0x00,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x00,0x96,0xB9,0xC2,
  0x00,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x01,0x00,0x01,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0x00,0xFF,
  0x03,0x01,0x01,0x00,0x06,
  0x63
};
static const struct mode_info mode6_info = {
    640, 200, (char *)0xb8000, 16384, 1, FALSE, FALSE
};

/* BIOS mode 0x07 */
static const u_char mode7_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x55,0x81,0xBF,0x1F,0x00,0x4F,0x0D,0x0E,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x0F,0x96,0xB9,0xA3,
  0x00,0x01,0x08,0x03,0x08,0x05,0x08,0x07,0x10,0x09,0x18,0x0B,
  0x18,0x0D,0x18,0x0F,0x0E,0x00,0x0F,0x08,0x00,
  0x00,0x00,0x00,0x00,0x00,0x10,0x0A,0x00,0xFF,
  0x03,0x00,0x03,0x00,0x02,
  0x66
};
static const struct mode_info mode7_info = {
    80, 25, (char *)0xb0000, 4096, 1, TRUE, FALSE
};

/* BIOS mode 0x0D */
static const u_char mode13_regs[60] = {
  0x2D,0x27,0x28,0x90,0x2B,0x80,0xBF,0x1F,0x00,0xC0,0x00,0x00,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x14,0x00,0x96,0xB9,0xE3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x10,0x11,0x12,0x13,
  0x14,0x15,0x16,0x17,0x01,0x00,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0xFF,
  0x03,0x09,0x0F,0x00,0x06,
  0x63
};
static const struct mode_info mode13_info = {
    320, 200, (char *)0xa0000, 8192, 8, FALSE, TRUE
};

/* BIOS mode 0x0E */
static const u_char mode14_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0xC0,0x00,0x00,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x00,0x96,0xB9,0xE3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x10,0x11,0x12,0x13,
  0x14,0x15,0x16,0x17,0x01,0x00,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0xFF,
  0x03,0x01,0x0F,0x00,0x06,
  0x63
};
static const struct mode_info mode14_info = {
    640, 200, (char *)0xa0000, 16384, 4, FALSE, TRUE
};

/* BIOS mode 0x0F */
static const u_char mode15_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x83,0x85,0x5D,0x28,0x0F,0x63,0xBA,0xE3,
  0x00,0x01,0x00,0x03,0x18,0x05,0x00,0x07,0x00,0x09,0x00,0x0B,
  0x00,0x0D,0x00,0x0F,0x0B,0x00,0x05,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05,0xFF,
  0x03,0x01,0x0F,0x00,0x06,
  0xA2
};
static const struct mode_info mode15_info = {
    640, 350, (char *)0xa0000, 28672, 2, FALSE, FALSE
};

/* BIOS mode 0x10 */
static const u_char mode16_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x83,0x85,0x5D,0x28,0x0F,0x63,0xBA,0xE3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,0x38,0x39,0x3A,0x3B,
  0x3C,0x3D,0x3E,0x3F,0x01,0x00,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0xFF,
  0x03,0x01,0x0F,0x00,0x06,
  0xA3
};
static const struct mode_info mode16_info = {
    640, 350, (char *)0xa0000, 28672, 2, FALSE, TRUE
};

/* BIOS mode 0x11 */
static const u_char mode17_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0xEA,0x8C,0xDF,0x28,0x00,0xE7,0x04,0xC3,
  0x00,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x01,0x00,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x01,0xFF,
  0x03,0x01,0x0F,0x00,0x06,
  0xE3
};
static const struct mode_info mode17_info = {
    640, 480, (char *)0xa0000, 38912, 1, FALSE, TRUE
};

/* BIOS mode 0x12 */
static const u_char mode18_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0xEA,0x8C,0xDF,0x28,0x00,0xE7,0x04,0xE3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,0x38,0x39,0x3A,0x3B,
  0x3C,0x3D,0x3E,0x3F,0x01,0x00,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0xFF,
  0x03,0x01,0x0F,0x00,0x06,
  0xE3
};
static const struct mode_info mode18_info = {
    640, 480, (char *)0xa0000, 38912, 1, FALSE, TRUE
};

/* BIOS mode 0x13 */
static const u_char mode19_regs[60] = {
  0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0x41,0x00,0x00,
  0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x40,0x96,0xB9,0xA3,
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,
  0x0C,0x0D,0x0E,0x0F,0x41,0x00,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0xFF,
  0x03,0x01,0x0F,0x00,0x0E,
  0x63
};
static const struct mode_info mode19_info = {
    640, 480, (char *)0xa0000, 38912, 1, FALSE, TRUE
};

#define LAST_MODE 19

static const u_char *bios_modes[LAST_MODE+1] = {
    mode0_regs, mode1_regs, mode2_regs, mode3_regs,
    mode4_regs, mode5_regs, mode6_regs, mode7_regs,
    0, 0, 0, 0,
    0, mode13_regs, mode14_regs, mode15_regs,
    mode16_regs, mode17_regs, mode18_regs, mode19_regs
};

static const struct mode_info *bios_mode_infos[LAST_MODE+1] = {
    &mode0_info, &mode1_info, &mode2_info, &mode3_info,
    &mode4_info, &mode5_info, &mode6_info, &mode7_info,
    0, 0, 0, 0,
    0, &mode13_info, &mode14_info, &mode15_info,
    &mode16_info, &mode17_info, &mode18_info, &mode19_info
};

/* Get the register set for the BIOS mode MODE. Returns TRUE if it can, and
   fills in *REGSP and *INFOP to point to the correct tables. Otherwise
   returns FALSE if MODE is not supported. */
inline bool
vga_get_mode(u_int mode, const u_char **regsp, const struct mode_info **infop)
{
    if(mode > LAST_MODE)
	return FALSE;
    *regsp = bios_modes[mode];
    *infop = bios_mode_infos[mode];
    return *regsp != NULL;
}



/* Turn off the display hardware. */
inline void
vga_disable_video(struct vga_info *inf)
{
    inb(inf->is1_r);
    outb(0x00, VGA_ATTR_IW);
}

/* Turn on the display hardware. */
inline void
vga_enable_video(struct vga_info *inf)
{
    inb(inf->is1_r);
    outb(0x20, VGA_ATTR_IW);
}

/* Saves the current state of the VGA hardware into INF. */
void
vga_save_regs(struct vga_info *inf)
{
    u_int i;
    for(i = 0; i < VGA_CRT_COUNT; i++)
    {
	outb(i, inf->crt_i);
	inf->regs[VGA_CRT_REGS+i] = inb(inf->crt_d);
    }
    for(i = 0; i < VGA_ATTR_COUNT; i++)
    {
	inb(inf->is1_r);
	outb(i, VGA_ATTR_IW);
	inf->regs[VGA_ATTR_REGS+i] = inb(VGA_ATTR_R);
    }
    for(i = 0; i < VGA_GRAPH_COUNT; i++)
    {
	outb(i, VGA_GRAPH_I);
	inf->regs[VGA_GRAPH_REGS+i] = inb(VGA_GRAPH_D);
    }
    for(i = 0; i < VGA_SEQ_COUNT; i++)
    {
	outb(i, VGA_SEQ_I);
	inf->regs[VGA_SEQ_REGS+i] = inb(VGA_SEQ_D);
    }
    inf->regs[VGA_MISC_REG] = inb(VGA_MISC_R);
}

/* Load the VGA registers stored in INF into the VGA hardware, the display
   is left disabled. */
void
vga_load_regs(struct vga_info *inf)
{
    u_int i;

    outb(inf->regs[VGA_MISC_REG], VGA_MISC_W);

    outb(0, VGA_SEQ_I);
    outb(0x01, VGA_SEQ_D);
    for(i = 0; i < VGA_SEQ_COUNT; i++)
    {
	outb(i, VGA_SEQ_I);
	outb(inf->regs[VGA_SEQ_REGS+i], VGA_SEQ_D);
    }
    outb(0, VGA_SEQ_I);
    outb(0x03, VGA_SEQ_D);

    outb(0x11, inf->crt_i);
    outb(inb(inf->crt_d) & 0x7f, inf->crt_d);
    for(i = 0; i < VGA_CRT_COUNT; i++)
    {
	outb(i, inf->crt_i);
	outb(inf->regs[VGA_CRT_REGS+i], inf->crt_d);
    }

    for(i = 0; i < VGA_GRAPH_COUNT; i++)
    {
	outb(i, VGA_GRAPH_I);
	outb(inf->regs[VGA_GRAPH_REGS+i], VGA_GRAPH_D);
    }

    for(i = 0; i < VGA_ATTR_COUNT; i++)
    {
	inb(inf->is1_r);
	outb(i, VGA_ATTR_IW);
	outb(inf->regs[VGA_ATTR_REGS+i], VGA_ATTR_IW);
    }
}

/* Put the virtual video V into BIOS mode MODE. Returns TRUE if this is
   possible. */
bool
vga_set_mode(struct video *v, u_int mode)
{
    const u_char *mode_regs;
    const struct mode_info *mode_info;
    if(!vga_get_mode(mode, &mode_regs, &mode_info))
	return FALSE;
    if(v->in_view)
	vga_disable_video(&v->vga);
    memcpy(&v->vga.regs, mode_regs, VGA_TOTAL_REGS);
    memcpy(&v->mi, mode_info, sizeof(struct mode_info));
    v->mode = mode;
    if(mode_regs[VGA_MISC_REG] & 0x01)
    {
	v->vga.crt_i = 0x3d4;
	v->vga.crt_d = 0x3d5;
	v->vga.is1_r = 0x3da;
    }
    else
    {
	v->vga.crt_i = 0x3b4;
	v->vga.crt_d = 0x3b5;
	v->vga.is1_r = 0x3ba;
    }
    if(v->in_view)
    {
	vga_load_regs(&v->vga);
	vga_enable_video(&v->vga);
    }
    return TRUE;
}
